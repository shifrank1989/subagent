/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cds2000.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>
#include "cJSON.h"
#define MAXBUFSIZE 1024

/** Initializes the cds2000 module */
//typedef struct ClusterInfo{
//    char physicalCapacity[50];
//    char PhysicalUsage[50];
//    //int  nodeCount;
//}CLUSTER ;
typedef struct PACKED
{
    char name[20];
    long total;
    char name2[20];
    long free;
}MEM_OCCUPY;
int get_online_disk_num();
char * get_Fan_Status(char ** fan_id);
char * fanstatus=NULL;
char  * get_cpu_temperature(char ** cpu_id);
int    get_cpu_num();
//char  * get_cpu_temperature(char ** cpu_id);
void get_mem_occupy(MEM_OCCUPY * mem);
double get_memory_total();
double get_memory_free();
char  * cpu_temperature;
//int get_net_num();
char PhysicalCapacityTB[10];
char TotalPhysicalUsageTB[10];
char SoftwareVersion[50];
//void getClusterStatus();
void  get_Cluster_Status();
char * POST_Authorization();
//char authorization_cmd[1024]="curl -s -k -X GET 'https://localhost/irisservices/api/v1/public/cluster?fetchStats=true' -H 'accept: application/json' -H 'Authorization:Bearer ";

void
init_cds2000(void)
{
    //POST_Authorization();
    const oid clusterStatus_oid[] = { 1,3,6,1,4,1,66018,1,2 };
    const oid clusterTotalSize_oid[] = { 1,3,6,1,4,1,66018,1,3 };
    const oid clusterFreeSize_oid[] = { 1,3,6,1,4,1,66018,1,4 };
    const oid storagePortNumber_oid[] = { 1,3,6,1,4,1,66018,1,5 };
    const oid onlineDiskNumber_oid[] = { 1,3,6,1,4,1,66018,1,6 };
    const oid memoryFreeCapacity_oid[] = { 1,3,6,1,4,1,66018,1,7 };
    const oid memoryTotalCapacity_oid[] = { 1,3,6,1,4,1,66018,1,8 };
    const oid cpuNumber_oid[] = { 1,3,6,1,4,1,66018,1,9 };
    const oid cpu1Temperature_oid[] = { 1,3,6,1,4,1,66018,1,10 };
    const oid cpu2Temperature_oid[] = { 1,3,6,1,4,1,66018,1,11 };
    const oid fanStatus1_oid[] = { 1,3,6,1,4,1,66018,1,12 };
    const oid fanStatus2_oid[] = { 1,3,6,1,4,1,66018,1,13 };
    const oid fanStatus3_oid[] = { 1,3,6,1,4,1,66018,1,14 };
    const oid fanStatus4_oid[] = { 1,3,6,1,4,1,66018,1,15 };
    const oid fanStatus5_oid[] = { 1,3,6,1,4,1,66018,1,16 };

  DEBUGMSGTL(("cds2000", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("clusterStatus", handle_clusterStatus,
                               clusterStatus_oid, OID_LENGTH(clusterStatus_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("clusterTotalSize", handle_clusterTotalSize,
                               clusterTotalSize_oid, OID_LENGTH(clusterTotalSize_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("clusterFreeSize", handle_clusterFreeSize,
                               clusterFreeSize_oid, OID_LENGTH(clusterFreeSize_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("storagePortNumber", handle_storagePortNumber,
                               storagePortNumber_oid, OID_LENGTH(storagePortNumber_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("onlineDiskNumber", handle_onlineDiskNumber,
                               onlineDiskNumber_oid, OID_LENGTH(onlineDiskNumber_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("memoryFreeCapacity", handle_memoryFreeCapacity,
                               memoryFreeCapacity_oid, OID_LENGTH(memoryFreeCapacity_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("memoryTotalCapacity", handle_memoryTotalCapacity,
                               memoryTotalCapacity_oid, OID_LENGTH(memoryTotalCapacity_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("cpuNumber", handle_cpuNumber,
                               cpuNumber_oid, OID_LENGTH(cpuNumber_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("cpu1Temperature", handle_cpu1Temperature,
                               cpu1Temperature_oid, OID_LENGTH(cpu1Temperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("cpu2Temperature", handle_cpu2Temperature,
                               cpu2Temperature_oid, OID_LENGTH(cpu2Temperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fanStatus1", handle_fanStatus1,
                               fanStatus1_oid, OID_LENGTH(fanStatus1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fanStatus2", handle_fanStatus2,
                               fanStatus2_oid, OID_LENGTH(fanStatus2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fanStatus3", handle_fanStatus3,
                               fanStatus3_oid, OID_LENGTH(fanStatus3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fanStatus4", handle_fanStatus4,
                               fanStatus4_oid, OID_LENGTH(fanStatus4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fanStatus5", handle_fanStatus5,
                               fanStatus5_oid, OID_LENGTH(fanStatus5_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_clusterStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            get_Cluster_Status();
            char clusterStatus[100];
            snprintf(clusterStatus,100,"%s",SoftwareVersion);
            //printf("进入循环/n");
            
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */ SoftwareVersion ,
                                     /* XXX: the length of the data in bytes */strlen(SoftwareVersion));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_clusterStatus\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_clusterTotalSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            //char clusterTotalSize[10];
            //snprintf(clusterTotalSize,10,"%4.2f", PhysicalCapacityTB);
           get_Cluster_Status();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */PhysicalCapacityTB,
                                     /* XXX: the length of the data in bytes */strlen(PhysicalCapacityTB));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_clusterTotalSize\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_clusterFreeSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            //char clusterFreeSize[10];
            get_Cluster_Status();
            //double clusterFreeSize_tmp=PhysicalCapacityTB - TotalPhysicalUsageTB;
            //snprintf(clusterFreeSize,10,"%4.2f", clusterFreeSize_tmp);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */ TotalPhysicalUsageTB,
                                     /* XXX: the length of the data in bytes */strlen(TotalPhysicalUsageTB));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_clusterFreeSize\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_storagePortNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char storagePortNumber[10];
            snprintf(storagePortNumber,10,"%d",get_net_num());
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */storagePortNumber,
                                     /* XXX: the length of the data in bytes */strlen(storagePortNumber));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_storagePortNumber\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_onlineDiskNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char onlineDiskNumber[10];
            snprintf(onlineDiskNumber,10,"%d",get_online_disk_num());
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */onlineDiskNumber,
                                     /* XXX: the length of the data in bytes */strlen(onlineDiskNumber));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_onlineDiskNumber\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_memoryFreeCapacity(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char memoryFreeCapacity[50];
            snprintf(memoryFreeCapacity,50,"%4.2f",get_memory_free());
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */memoryFreeCapacity,
                                     /* XXX: the length of the data in bytes */strlen(memoryFreeCapacity));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_memoryFreeCapacity\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_memoryTotalCapacity(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char memoryTotalCapacity[50];
            snprintf(memoryTotalCapacity, 50,"%4.2f",get_memory_total());
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */memoryTotalCapacity,
                                     /* XXX: the length of the data in bytes */strlen(memoryTotalCapacity));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_memoryTotalCapacity\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_cpuNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char cpuNumber[10];
            snprintf(cpuNumber,10,"%d",get_cpu_num());
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */ cpuNumber,
                                     /* XXX: the length of the data in bytes */strlen(cpuNumber));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpuNumber\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_cpu1Temperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char a[20]="'CPU1 Temp'";//supermicro
            //char a[20]="'BB CPU1 VR Temp'";//intel
            char *cpu_id=a;
            char cpu1Temperature[10];
            snprintf(cpu1Temperature, 10, "%s",get_cpu_temperature(&cpu_id));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */cpu1Temperature,
                                     /* XXX: the length of the data in bytes */strlen(cpu1Temperature));
            break;

        }
        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpu1Temperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_cpu2Temperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char a[20]="'CPU2 Temp'";//supermicro
            //char a[20]="'BB CPU2 VR Temp'";//intel
            char *cpu_id=a;
            char cpu2Temperature[10];
            snprintf(cpu2Temperature, 10, "%s",get_cpu_temperature(&cpu_id));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */cpu2Temperature,
                                     /* XXX: the length of the data in bytes */strlen(cpu2Temperature));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpu2Temperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_fanStatus1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char fan1[10]="'FAN1'";//supermicro
            //char fan1[20]="'Sys Fan 1A'";//intel
            char *fan_id1=fan1;
            char fanstatus1[10];
            snprintf(fanstatus1, 10, "%s",get_Fan_Status(&fan_id1));
            
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */fanstatus1,
                                     /* XXX: the length of the data in bytes */strlen(fanstatus1));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fanStatus1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_fanStatus2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char fan2[10]="'FAN2'";//supermicro
            //char fan2[20]="'Sys Fan 2A'";//intel
            char *fan_id2=fan2;
            char fanstatus2[10];
            snprintf(fanstatus2, 10, "%s",get_Fan_Status(&fan_id2));
            
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */fanstatus2,
                                     /* XXX: the length of the data in bytes */strlen(fanstatus2));
            break;

        }
        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fanStatus2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_fanStatus3(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char fan3[10]="'FAN3'";//supermicro
            //char fan3[20]="'Sys Fan 3A'";//intel
            char *fan_id3=fan3;
            char fanstatus3[10];
            snprintf(fanstatus3, 10, "%s",get_Fan_Status(&fan_id3));
            
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */ fanstatus3,
                                     /* XXX: the length of the data in bytes */strlen(fanstatus3));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fanStatus3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_fanStatus4(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char fan4[10]="'FAN4'";//supermicro
            //char fan4[20]="'Sys Fan 1B'";//intel
            char *fan_id4=fan4;
            char fanstatus4[10];
            snprintf(fanstatus4, 10, "%s",get_Fan_Status(&fan_id4));
            
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */fanstatus4,
                                     /* XXX: the length of the data in bytes */strlen(fanstatus4));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fanStatus4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_fanStatus5(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:{
            char fan5[10]="'FAN5'";//supermicro
            //char fan5[20]="'Sys Fan 2B'";//intel
            char *fan_id5=fan5;
            char fanstatus5[10];
            snprintf(fanstatus5, 10, "%s",get_Fan_Status(&fan_id5));
            
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */fanstatus5,
                                     /* XXX: the length of the data in bytes */strlen(fanstatus5));
            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fanStatus5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
//风扇状态
char * get_Fan_Status(char ** fan_id){
    FILE * fan_status;
    //char fanstatus[5];
    char buff[MAXBUFSIZE];
    char a[20];
    char b[20];
    char c[20];
    char fan_status_cmd[50]="sudo ipmitool sensor get ";
    strcat (fan_status_cmd,*fan_id);
    fan_status = popen(fan_status_cmd,"r");
    int i=0;    
    while(i++<30){
        if(fgets (buff, sizeof(buff), fan_status)!=NULL){
            sscanf (buff, "%s %s %s ",a,b,c);
            if(strcmp(a, "Status")==0){
                //printf("fan status :%s \n",c);
                //strcpy(fanstatus,c);
                fanstatus=c;
                break;
            }
        }
    }
    fclose(fan_status);
    return fanstatus;
}
//cpu温度
char * get_cpu_temperature(char ** cpu_id){
    FILE * cpu_temp;
    char buff[MAXBUFSIZE];
    char a[20];
    char b[20];
    char c[20];
    char d[20];
    char cpu_temp_cmd[50]="sudo ipmitool sensor get ";
    strcat (cpu_temp_cmd,*cpu_id);
    cpu_temp = popen(cpu_temp_cmd,"r");
    int i=0;
    while(i++<30){
        if(fgets (buff, sizeof(buff), cpu_temp)!=NULL){
            sscanf (buff, "%s %s %s %s",a,b,c,d);
            if(strcmp(b, "Reading")==0){
                cpu_temperature=d;
                break;
            }
        }
    }
    fclose(cpu_temp);
    return cpu_temperature;
}
//cpu核心数
int get_cpu_num(){
    int cpu_num;
    cpu_num = sysconf(_SC_NPROCESSORS_ONLN);
    return cpu_num;
}
//内存总量
double get_memory_total(){
    MEM_OCCUPY mem;
    get_mem_occupy(&mem);
    double memory_total=mem.total;
    return memory_total;
}
//内存剩余
double get_memory_free(){
    MEM_OCCUPY mem;
    get_mem_occupy(&mem);
    double memory_free=mem.free;
    return memory_free;
}
void get_mem_occupy(MEM_OCCUPY * mem){
    FILE * fd;
    char buff[MAXBUFSIZE];
    fd = fopen("/proc/meminfo","r");
    fgets (buff, sizeof(buff), fd);
    sscanf (buff, "%s %ld", mem->name,&mem->total);
    fgets (buff, sizeof(buff), fd);
    sscanf (buff, "%s %ld", mem->name2,&mem->free);
    fclose(fd);
}
//在线磁盘数
int get_online_disk_num(){
    FILE * disk_num;
    int disk_number;
    char buff[MAXBUFSIZE];
    char disk[20];
    char a[20];
    char b[20];
    char c[20];
    
    char j[20];
    disk_num = popen("lsscsi -w","r");
    int i = 0;
    int num=0;
    while(i++<27){
        if(fgets (buff, sizeof(buff), disk_num)!=NULL){
            sscanf (buff, "%s %s %s %s ",disk,a,b,c);
            if(strcmp(a, "disk")==0){
                num+=1;
            }
        }
    }
    sprintf(j,"%d",num);
    disk_number=num;
    //strcpy(*disknum, j);
    
    fclose(disk_num);
    
    return disk_number;
}
//网口数量
int get_net_num(){
    int net_number;
    FILE * net_num;
    char buff[MAXBUFSIZE];
    net_num = popen("lspci | grep Ethernet","r");
    int i = 0;
    int num = 0;
    while(i++<27){
        if(fgets (buff, sizeof(buff), net_num)!=NULL){
                num+=1;
        }
    }
    //sprintf(j,"%d",num);
    net_number=num;
    fclose(net_num);
    return net_number;
}
//集群信息
void  get_Cluster_Status(){
    FILE * cluster_status;
    //CLUSTER *pCluinfo = malloc(sizeof(CLUSTER));
    //printf("标记: 进入获取集群信息函数");
    char buff[2048];
    char a[20];
    char b[50];
    char c[50];
    char d[50];
    POST_Authorization();
    char * cmd =NULL;
    cmd=POST_Authorization();
    //cmd=authorization_cmd;
    cluster_status = popen(cmd,"r");
    //printf("标记获取集群信息成功/n");
    if(fgets (buff, sizeof(buff), cluster_status)!=NULL){
        sscanf (buff, "%s\n",a);
        //printf("cluster info: %s\n",a);
        cJSON * root = NULL;
        cJSON * item = NULL;//cjson对象
        cJSON * clusterStatus=NULL;
        cJSON * physicalCapacity=NULL;
        cJSON * totalPhysicalUsageBytes=NULL;
        root = cJSON_Parse(a);
        if (!root)
        {
            printf("Error before: [%s]\n",cJSON_GetErrorPtr());
        }
        else
        {
            clusterStatus=cJSON_GetObjectItem(root, "clusterSoftwareVersion");
            sprintf(b,"%s",clusterStatus->valuestring);
            snprintf(SoftwareVersion, sizeof(b), "%s",b);
            item = cJSON_GetObjectItem(root, "stats");
//            printf("1: %s\n", cJSON_Print(item));
            item = cJSON_GetObjectItem(item, "localUsagePerfStats");
            
            physicalCapacity = cJSON_GetObjectItem(item, "physicalCapacityBytes");
            sprintf(c,"%4.2f",((physicalCapacity->valuedouble)/1024/1024/1024/1024));
            //strcpy(pCluinfo->physicalCapacity, c) ;
            snprintf(PhysicalCapacityTB, sizeof(c), "%s",c);
            
            totalPhysicalUsageBytes=cJSON_GetObjectItem(item, "totalPhysicalUsageBytes");
            sprintf(d,"%4.2f",((totalPhysicalUsageBytes->valuedouble)/1024/1024/1024/1024));
            //strcpy(pCluinfo->PhysicalUsage,d) ;
            snprintf(TotalPhysicalUsageTB, sizeof(d), "%s",d);
            
            cJSON_Delete(root);
        }
    }
    fclose(cluster_status);
    //authorization_cmd={0};
    
    //free(pCluinfo);
    //free(buff);
    
}

char * POST_Authorization(){
    //printf("标记进入获取权限函数/n");
    char buff[MAXBUFSIZE];
    char a[20];
    char * accessToken=NULL;
    FILE * authorization;
    char * cmd= "curl -s -k -X POST 'https://localhost/irisservices/api/v1/public/accessTokens' -H 'accept: application/json' -H 'content-type: application/json' -d '{ \"domain\": \"LOCAL\", \"password\": \"admin\", \"username\": \"admin\"}'";
    char authorization_cmd[1024]="curl -s -k -X GET 'https://localhost/irisservices/api/v1/public/cluster?fetchStats=true' -H 'accept: application/json' -H 'Authorization:Bearer ";
    authorization = popen(cmd, "r");
    //printf("标记获取权限成功/n");
    if(fgets (buff, sizeof(buff), authorization)!=NULL){
        sscanf (buff, "%s\n",a);
        cJSON * root = NULL;
        cJSON * item = NULL;
        root = cJSON_Parse(a);
        
        if (!root)
        {
            printf("Error before: [%s]\n",cJSON_GetErrorPtr());
        }
        else
        {
            item = cJSON_GetObjectItem(root, "accessToken");
            accessToken=item->valuestring;
        }
        cJSON_Delete(root);
    }
    fclose(authorization);
    strcat (authorization_cmd,accessToken);
    strcat (authorization_cmd,"'");
    //printf("标记权限词条拼接成功/n");
    return authorization_cmd;
}


static int keep_running;
RETSIGTYPE stop_server(int __attribute__((unused)) a) {
    keep_running = 0;
}

int main()
{
    const char *app_name = "cds2000";
    /* we are a subagent */
    netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_ROLE, 1);
    
    /* initialize the agent library */
    init_agent(app_name);
    
    /* initialize your mib code here */
    init_cds2000();
    
    /* cds2000 will be used to read cds2000.conf files. */
    init_snmp("cds2000");
    keep_running = 1;
    while(keep_running)
    {
        agent_check_and_process(1);/* block every 1 second */
    }
    /* at shutdown time */
    snmp_shutdown(app_name);
    
    /* deinitialize your mib code here */
    
    /* shutdown the agent library */
    shutdown_agent();
    return 0;
}
